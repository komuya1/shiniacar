<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OpenStreetMap シニアカー（AR付き）</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    body {
      font-family: "Noto Sans JP", sans-serif;
      margin: 0;
      background: #f0f0f0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    header {
      background: #2c3e50;
      color: white;
      text-align: center;
      padding: 10px;
      font-size: 1.2rem;
    }
    #controls {
      display: flex;
      gap: 8px;
      padding: 10px;
      background: #ecf0f1;
      flex-wrap: wrap;
      justify-content: center;
    }
    input { padding: 8px; border-radius: 6px; border: 1px solid #bbb; flex: 1; min-width: 150px; }
    button { padding: 8px 12px; border: none; border-radius: 6px; background: #3498db; color: white; cursor: pointer; font-weight: bold; }
    button:hover { background: #2980b9; }

    #map { flex: 1; min-height: 200px; }

    #summary { text-align: center; padding: 8px; background: #fff; border-top: 1px solid #ccc; font-size: 1rem; }
    #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.7); color: white; padding: 16px 24px; border-radius: 10px; font-size: 1.1rem; display:none; z-index:1000; }

    /* AR overlay styles */
    #arContainer {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none; /* shown when AR mode on */
      z-index: 1200;
      pointer-events: none;
    }
    #cameraVideo {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* mirror so it feels natural for user-facing? optional */
    }
    #arOverlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      pointer-events: none;
    }
    .arTop {
      display:flex; justify-content:space-between; padding: 12px;
      font-size: 0.95rem; color: white; text-shadow: 0 1px 3px rgba(0,0,0,.7);
      pointer-events: auto;
    }
    .arCenter {
      display:flex; align-items:center; justify-content:center; pointer-events:none;
    }
    /* arrow */
    .arrow {
      width: 120px; height: 120px;
      transition: transform 0.2s linear;
      transform-origin: 50% 50%;
      filter: drop-shadow(0 4px 6px rgba(0,0,0,0.6));
    }
    .distanceBox {
      margin-top: 12px;
      background: rgba(0,0,0,0.5);
      color: white; padding: 8px 12px; border-radius: 8px;
      font-weight: bold; text-align:center;
    }

    /* small AR controls */
    #arControls {
      position: absolute; top: 12px; right: 12px; z-index: 1300;
      display:flex; gap:8px; pointer-events: auto;
    }
    #arControls button { background: rgba(255,255,255,0.9); color: #333; padding:6px 8px; border-radius:6px; font-weight:600; }

    footer { text-align:center; padding:8px; font-size:12px; color:#555; z-index:0; }
  </style>
</head>
<body>
  <header> OpenStreetMap シニアカーナビ（AR付き・テスト）</header>

  <div id="controls">
    <input id="from" type="text" placeholder="出発地（例：現在地）">
    <input id="to" type="text" placeholder="目的地（例：東京タワー）">
    <button id="goBtn">ルート表示</button>
    <button id="gpsBtn">📍 現在地</button>
    <button id="arBtn">📸 ARモード</button>
  </div>

  <div id="map"></div>
  <div id="summary"></div>
  <div id="loading"> ルートを検索中...</div>

  <!-- AR container -->
  <div id="arContainer" aria-hidden="true">
    <video id="cameraVideo" autoplay playsinline muted></video>

    <div id="arOverlay">
      <div class="arTop">
        <div id="arStatus">ARモード</div>
        <div id="arDistance"></div>
      </div>

      <div class="arCenter">
        <!-- SVG arrow; we rotate this according to relative bearing -->
        <div style="text-align:center;">
          <svg class="arrow" id="arrowSvg" viewBox="0 0 100 100">
            <polygon points="50,5 90,90 50,75 10,90" fill="rgba(255,255,255,0.95)"/>
          </svg>
          <div class="distanceBox" id="arInfo">-- m</div>
        </div>
      </div>

      <div style="display:flex; justify-content:center; padding:12px;">
        <div id="arHint" style="color:white; text-shadow:0 1px 3px rgba(0,0,0,.7)">端末を回して進行方向に合わせてください</div>
      </div>
    </div>

    <div id="arControls">
      <button id="stopArBtn">AR終了</button>
    </div>
  </div>

  <footer>© OpenStreetMap contributors | OSRM経路API使用</footer>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    // --- 既存の地図・ルート処理（あなたのコードに合わせて統合） ---
    const map = L.map('map').setView([35.6812, 139.7671], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    let routeLine = null;
    let markers = [];
    let currentLocation = null;
    let route = null; // フルルート情報を保持
    let routeCoords = []; // [lat, lon] の配列

    async function getCoordinates(place) {
      if (!place) return null;
      const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(place)}`);
      const data = await res.json();
      if (!data || data.length === 0) return null;
      return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
    }

    function getCurrentLocation() {
      if (!navigator.geolocation) {
        alert("このブラウザはGPSをサポートしていません。");
        return;
      }
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          currentLocation = [pos.coords.latitude, pos.coords.longitude];
          map.setView(currentLocation, 14);
          L.marker(currentLocation).addTo(map).bindPopup("📍 現在地").openPopup();
          document.getElementById("from").value = "現在地";
        },
        (err) => alert("現在地を取得できませんでした: " + err.message),
        { enableHighAccuracy: true }
      );
    }

    async function drawRoute() {
      const fromInput = document.getElementById("from").value.trim();
      const toInput = document.getElementById("to").value.trim();
      const summary = document.getElementById("summary");
      const loading = document.getElementById("loading");
      summary.textContent = "";

      if (!toInput) {
        summary.textContent = "目的地を入力してください。";
        return;
      }

      loading.style.display = "block";

      let fromCoords;
      if (fromInput === "現在地" && currentLocation) {
        fromCoords = currentLocation;
      } else {
        fromCoords = await getCoordinates(fromInput);
      }

      const toCoords = await getCoordinates(toInput);
      if (!fromCoords || !toCoords) {
        loading.style.display = "none";
        summary.textContent = "地名が見つかりません。";
        return;
      }

      // OSRM で自転車（bike）ルートを取得
      const url = `https://router.project-osrm.org/route/v1/bike/${fromCoords[1]},${fromCoords[0]};${toCoords[1]},${toCoords[0]}?overview=full&geometries=geojson&steps=true`;
      const res = await fetch(url);
      const data = await res.json();
      loading.style.display = "none";

      if (!data.routes || data.routes.length === 0) {
        summary.textContent = "ルートが見つかりませんでした。";
        return;
      }

      route = data.routes[0];
      routeCoords = route.geometry.coordinates.map(c => [c[1], c[0]]); // [lat,lon]

      if (routeLine) map.removeLayer(routeLine);
      markers.forEach(m => map.removeLayer(m));
      markers = [];

      routeLine = L.polyline(routeCoords, { color: '#00b894', weight: 5 }).addTo(map);
      map.fitBounds(routeLine.getBounds());

      markers.push(L.marker(fromCoords).addTo(map).bindPopup("出発地"));
      markers.push(L.marker(toCoords).addTo(map).bindPopup("目的地"));

const distKm = (route.distance / 1000).toFixed(1);

// シニアカーの平均速度（6km/h）で時間を再計算
  const seniorSpeed = 6; // km/h
  const timeMin = Math.round((distKm / seniorSpeed) * 60);

  summary.innerHTML = `<b>距離:</b> ${distKm} km ／ <b>所要時間（シニアカー）:</b> 約${timeMin}分`;

  speak(`出発地から目的地までのルートを案内します。距離は約${distKm}キロ、シニアカーでの所要時間はおよそ${timeMin}分です。`);

    }

    function speak(text) {
      if (!("speechSynthesis" in window)) return;
      const utter = new SpeechSynthesisUtterance(text);
      utter.lang = "ja-JP";
      utter.rate = 1;
      speechSynthesis.speak(utter);
    }

    document.getElementById("gpsBtn").addEventListener("click", getCurrentLocation);
    document.getElementById("goBtn").addEventListener("click", drawRoute);

    // --- AR機能の実装 ---
    const arBtn = document.getElementById('arBtn');
    const arContainer = document.getElementById('arContainer');
    const cameraVideo = document.getElementById('cameraVideo');
    const arrowSvg = document.getElementById('arrowSvg');
    const arInfo = document.getElementById('arInfo');
    const arDistance = document.getElementById('arDistance');
    const arStatus = document.getElementById('arStatus');
    const stopArBtn = document.getElementById('stopArBtn');
    let arStream = null;
    let watchingPositionId = null;
    let deviceHeading = null; // degrees, 0 = north
    let orientationListener = null;

    // ヘディング取得（DeviceOrientationAbsolute を優先）
    function setupOrientationListener() {
      // iOS Safari では DeviceOrientationEvent.requestPermission が必要
      function handleOrientation(e) {
        // alpha: rotation around z-axis (compass), but depends on device/browser.
        // Try to use 'webkitCompassHeading' where available (iOS).
        if (e.webkitCompassHeading !== undefined) {
          deviceHeading = e.webkitCompassHeading; // 0..360 (degrees clockwise from north)
        } else if (e.absolute === true || e.absolute === undefined) {
          // alpha rotation is degrees from device start; might need conversion based on screen orientation.
          if (e.alpha != null) {
            // Convert alpha to compass heading:
            // e.alpha: 0 at device's reference (magnetic north on some implementations). This is approximate.
            deviceHeading = 360 - e.alpha; // best-effort
          }
        }
      }

      // Modern browsers may require user gesture to request permission
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
          .then(permissionState => {
            if (permissionState === 'granted') {
              window.addEventListener('deviceorientation', handleOrientation, true);
              orientationListener = handleOrientation;
            } else {
              arStatus.textContent = "向き情報の許可が必要です（表示は不正確かもしれません）";
            }
          })
          .catch(err => {
            console.warn('DeviceOrientation permission error', err);
            arStatus.textContent = "向き情報が取得できません。";
          });
      } else {
        // 標準イベント
        window.addEventListener('deviceorientation', handleOrientation, true);
        orientationListener = handleOrientation;
      }
    }

    function stopOrientationListener() {
      if (orientationListener) {
        window.removeEventListener('deviceorientation', orientationListener, true);
        orientationListener = null;
      }
    }

    // カメラ開始
    async function startCamera() {
      try {
        arStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
        cameraVideo.srcObject = arStream;
        await cameraVideo.play();
        arContainer.style.display = 'block';
      } catch (err) {
        alert('カメラを開始できませんでした: ' + err.message);
      }
    }

    function stopCamera() {
      if (arStream) {
        arStream.getTracks().forEach(t => t.stop());
        arStream = null;
      }
      cameraVideo.pause();
      cameraVideo.srcObject = null;
      arContainer.style.display = 'none';
    }

    // ２点の方位（bearing）を求める（degrees）
    function bearingBetween(lat1, lon1, lat2, lon2) {
      const toRad = Math.PI / 180;
      const toDeg = 180 / Math.PI;
      const φ1 = lat1 * toRad;
      const φ2 = lat2 * toRad;
      const λ1 = lon1 * toRad;
      const λ2 = lon2 * toRad;
      const y = Math.sin(λ2 - λ1) * Math.cos(φ2);
      const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(λ2 - λ1);
      let θ = Math.atan2(y, x);
      θ = θ * toDeg;
      return (θ + 360) % 360;
    }

    // 距離（メートル）
    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const toRad = Math.PI / 180;
      const dLat = (lat2 - lat1) * toRad;
      const dLon = (lon2 - lon1) * toRad;
      const a = Math.sin(dLat/2)**2 + Math.cos(lat1*toRad)*Math.cos(lat2*toRad)*Math.sin(dLon/2)**2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    // ルート上の「次の注目点」を探す（単純に最も近い後方でなく前方のポイント）
    function findNextPointOnRoute(current) {
      if (!routeCoords || routeCoords.length === 0) return null;
      // 現在地から順に最近点を探す（シンプル実装）
      let minDist = Infinity;
      let idx = 0;
      for (let i = 0; i < routeCoords.length; i++) {
        const p = routeCoords[i];
        const d = haversineDistance(current[0], current[1], p[0], p[1]);
        if (d < minDist) {
          minDist = d; idx = i;
        }
      }
      // 進行方向を考え、idx+N点を次の目標にする（N=5 ほど）
      const lookAhead = Math.min(idx + 8, routeCoords.length - 1);
      return { point: routeCoords[lookAhead], distToPoint: haversineDistance(current[0], current[1], routeCoords[lookAhead][0], routeCoords[lookAhead][1]) };
    }

    // 位置更新ハンドラ：AR中は頻繁に呼ばれる
    async function startWatchingPosition() {
      if (!navigator.geolocation) {
        alert('位置情報が使えません。');
        return;
      }
      if (watchingPositionId !== null) return;
      watchingPositionId = navigator.geolocation.watchPosition(pos => {
        currentLocation = [pos.coords.latitude, pos.coords.longitude];
        // AR表示を更新
        updateAR();
      }, err => {
        console.warn('位置監視エラー', err);
      }, { enableHighAccuracy: true, maximumAge: 1000, timeout: 5000 });
    }

    function stopWatchingPosition() {
      if (watchingPositionId !== null) {
        navigator.geolocation.clearWatch(watchingPositionId);
        watchingPositionId = null;
      }
    }

    // AR表示更新（矢印の回転、距離表示、音声案内トリガ）
    let lastSpokenStep = null;
    function updateAR() {
      if (!currentLocation || !routeCoords || routeCoords.length === 0) {
        arInfo.textContent = '-- m';
        return;
      }
      const next = findNextPointOnRoute(currentLocation);
      if (!next) return;
      const target = next.point; // [lat,lon]
      const dist = Math.round(next.distToPoint);
      const bearingToTarget = bearingBetween(currentLocation[0], currentLocation[1], target[0], target[1]); // degrees
      const heading = (deviceHeading != null) ? deviceHeading : 0; // degrees
      const relative = ((bearingToTarget - heading + 540) % 360) - 180; // -180..180 (right positive)
      // rotate arrow: because video is mirrored via CSS scaleX(-1), invert rotation sign for natural feel
      arrowSvg.style.transform = `rotate(${relative}deg)`;

      arInfo.textContent = `${dist} m`;
      arDistance.textContent = `目標まで ${dist} m`;

      // 案内の発話（近づいたら次の音声）
      if (dist < 50 && lastSpokenStep !== 'near') {
        speak('目的地が近づいています。減速してご注意ください。');
        lastSpokenStep = 'near';
      } else if (dist >= 50) {
        lastSpokenStep = null;
      }
    }

    // AR開始
    arBtn.addEventListener('click', async () => {
      // ルートが無ければ先に作成を促す
      if (!route || !routeCoords || routeCoords.length === 0) {
        alert('ARを使う前に「ルート表示」で目的地を設定してください。');
        return;
      }

      // カメラ開始
      await startCamera();

      // 向き情報のリスナーをセット
      setupOrientationListener();

      // 位置更新監視
      await startWatchingPosition();

      // show overlay
      arContainer.style.display = 'block';
      arStatus.textContent = 'ARモード（カメラ・位置・方位を使用）';
      speak('ARナビを開始します。端末を回して進行方向を合わせてください。');

      // 初回更新
      updateAR();
    });

    stopArBtn.addEventListener('click', () => {
      stopCamera();
      stopWatchingPosition();
      stopOrientationListener();
      arContainer.style.display = 'none';
      speak('ARモードを終了しました。');
    });

    // ページ離脱時のクリーンアップ
    window.addEventListener('beforeunload', () => {
      stopCamera(); stopWatchingPosition(); stopOrientationListener();
    });

    // (オプション) mapクリックで現在地更新
    map.on('click', (e) => {
      // debug: マップをタップすると現在位置をセット（テスト用）
      currentLocation = [e.latlng.lat, e.latlng.lng];
      if (routeLine) {
        map.panTo(e.latlng);
      }
    });

    // 最後に—初回の簡易メッセージ
    document.addEventListener('DOMContentLoaded', () => {
      const s = document.getElementById('summary');
      s.textContent = '目的地を入力して「ルート表示」。ARモードは屋外での使用を想定しています。';
    });
  </script>
</body>
</html>
