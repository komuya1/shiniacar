<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OpenStreetMap ã‚·ãƒ‹ã‚¢ã‚«ãƒ¼ï¼ˆARä»˜ãï¼‰</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    body {
      font-family: "Noto Sans JP", sans-serif;
      margin: 0;
      background: #f0f0f0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    header {
      background: #2c3e50;
      color: white;
      text-align: center;
      padding: 10px;
      font-size: 1.2rem;
    }
    #controls {
      display: flex;
      gap: 8px;
      padding: 10px;
      background: #ecf0f1;
      flex-wrap: wrap;
      justify-content: center;
    }
    input { padding: 8px; border-radius: 6px; border: 1px solid #bbb; flex: 1; min-width: 150px; }
    button { padding: 8px 12px; border: none; border-radius: 6px; background: #3498db; color: white; cursor: pointer; font-weight: bold; }
    button:hover { background: #2980b9; }

    #map { flex: 1; min-height: 200px; }

    #summary { text-align: center; padding: 8px; background: #fff; border-top: 1px solid #ccc; font-size: 1rem; }
    #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.7); color: white; padding: 16px 24px; border-radius: 10px; font-size: 1.1rem; display:none; z-index:1000; }

    /* AR overlay styles */
    #arContainer {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none; /* shown when AR mode on */
      z-index: 1200;
      pointer-events: none;
    }
    #cameraVideo {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* mirror so it feels natural for user-facing? optional */
    }
    #arOverlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      pointer-events: none;
    }
    .arTop {
      display:flex; justify-content:space-between; padding: 12px;
      font-size: 0.95rem; color: white; text-shadow: 0 1px 3px rgba(0,0,0,.7);
      pointer-events: auto;
    }
    .arCenter {
      display:flex; align-items:center; justify-content:center; pointer-events:none;
    }
    /* arrow */
    .arrow {
      width: 120px; height: 120px;
      transition: transform 0.2s linear;
      transform-origin: 50% 50%;
      filter: drop-shadow(0 4px 6px rgba(0,0,0,0.6));
    }
    .distanceBox {
      margin-top: 12px;
      background: rgba(0,0,0,0.5);
      color: white; padding: 8px 12px; border-radius: 8px;
      font-weight: bold; text-align:center;
    }

    /* small AR controls */
    #arControls {
      position: absolute; top: 12px; right: 12px; z-index: 1300;
      display:flex; gap:8px; pointer-events: auto;
    }
    #arControls button { background: rgba(255,255,255,0.9); color: #333; padding:6px 8px; border-radius:6px; font-weight:600; }

    footer { text-align:center; padding:8px; font-size:12px; color:#555; z-index:0; }
  </style>
</head>
<body>
  <header> OpenStreetMap ã‚·ãƒ‹ã‚¢ã‚«ãƒ¼ãƒŠãƒ“ï¼ˆARä»˜ããƒ»ãƒ†ã‚¹ãƒˆï¼‰</header>

  <div id="controls">
    <input id="from" type="text" placeholder="å‡ºç™ºåœ°ï¼ˆä¾‹ï¼šç¾åœ¨åœ°ï¼‰">
    <input id="to" type="text" placeholder="ç›®çš„åœ°ï¼ˆä¾‹ï¼šæ±äº¬ã‚¿ãƒ¯ãƒ¼ï¼‰">
    <button id="goBtn">ãƒ«ãƒ¼ãƒˆè¡¨ç¤º</button>
    <button id="gpsBtn">ğŸ“ ç¾åœ¨åœ°</button>
    <button id="arBtn">ğŸ“¸ ARãƒ¢ãƒ¼ãƒ‰</button>
  </div>

  <div id="map"></div>
  <div id="summary"></div>
  <div id="loading"> ãƒ«ãƒ¼ãƒˆã‚’æ¤œç´¢ä¸­...</div>

  <!-- AR container -->
  <div id="arContainer" aria-hidden="true">
    <video id="cameraVideo" autoplay playsinline muted></video>

    <div id="arOverlay">
      <div class="arTop">
        <div id="arStatus">ARãƒ¢ãƒ¼ãƒ‰</div>
        <div id="arDistance"></div>
      </div>

      <div class="arCenter">
        <!-- SVG arrow; we rotate this according to relative bearing -->
        <div style="text-align:center;">
          <svg class="arrow" id="arrowSvg" viewBox="0 0 100 100">
            <polygon points="50,5 90,90 50,75 10,90" fill="rgba(255,255,255,0.95)"/>
          </svg>
          <div class="distanceBox" id="arInfo">-- m</div>
        </div>
      </div>

      <div style="display:flex; justify-content:center; padding:12px;">
        <div id="arHint" style="color:white; text-shadow:0 1px 3px rgba(0,0,0,.7)">ç«¯æœ«ã‚’å›ã—ã¦é€²è¡Œæ–¹å‘ã«åˆã‚ã›ã¦ãã ã•ã„</div>
      </div>
    </div>

    <div id="arControls">
      <button id="stopArBtn">ARçµ‚äº†</button>
    </div>
  </div>

  <footer>Â© OpenStreetMap contributors | OSRMçµŒè·¯APIä½¿ç”¨</footer>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    // --- æ—¢å­˜ã®åœ°å›³ãƒ»ãƒ«ãƒ¼ãƒˆå‡¦ç†ï¼ˆã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã«åˆã‚ã›ã¦çµ±åˆï¼‰ ---
    const map = L.map('map').setView([35.6812, 139.7671], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    let routeLine = null;
    let markers = [];
    let currentLocation = null;
    let route = null; // ãƒ•ãƒ«ãƒ«ãƒ¼ãƒˆæƒ…å ±ã‚’ä¿æŒ
    let routeCoords = []; // [lat, lon] ã®é…åˆ—

    async function getCoordinates(place) {
      if (!place) return null;
      const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(place)}`);
      const data = await res.json();
      if (!data || data.length === 0) return null;
      return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
    }

    function getCurrentLocation() {
      if (!navigator.geolocation) {
        alert("ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯GPSã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚");
        return;
      }
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          currentLocation = [pos.coords.latitude, pos.coords.longitude];
          map.setView(currentLocation, 14);
          L.marker(currentLocation).addTo(map).bindPopup("ğŸ“ ç¾åœ¨åœ°").openPopup();
          document.getElementById("from").value = "ç¾åœ¨åœ°";
        },
        (err) => alert("ç¾åœ¨åœ°ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ: " + err.message),
        { enableHighAccuracy: true }
      );
    }

    async function drawRoute() {
      const fromInput = document.getElementById("from").value.trim();
      const toInput = document.getElementById("to").value.trim();
      const summary = document.getElementById("summary");
      const loading = document.getElementById("loading");
      summary.textContent = "";

      if (!toInput) {
        summary.textContent = "ç›®çš„åœ°ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚";
        return;
      }

      loading.style.display = "block";

      let fromCoords;
      if (fromInput === "ç¾åœ¨åœ°" && currentLocation) {
        fromCoords = currentLocation;
      } else {
        fromCoords = await getCoordinates(fromInput);
      }

      const toCoords = await getCoordinates(toInput);
      if (!fromCoords || !toCoords) {
        loading.style.display = "none";
        summary.textContent = "åœ°åãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚";
        return;
      }

      // OSRM ã§è‡ªè»¢è»Šï¼ˆbikeï¼‰ãƒ«ãƒ¼ãƒˆã‚’å–å¾—
      const url = `https://router.project-osrm.org/route/v1/bike/${fromCoords[1]},${fromCoords[0]};${toCoords[1]},${toCoords[0]}?overview=full&geometries=geojson&steps=true`;
      const res = await fetch(url);
      const data = await res.json();
      loading.style.display = "none";

      if (!data.routes || data.routes.length === 0) {
        summary.textContent = "ãƒ«ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚";
        return;
      }

      route = data.routes[0];
      routeCoords = route.geometry.coordinates.map(c => [c[1], c[0]]); // [lat,lon]

      if (routeLine) map.removeLayer(routeLine);
      markers.forEach(m => map.removeLayer(m));
      markers = [];

      routeLine = L.polyline(routeCoords, { color: '#00b894', weight: 5 }).addTo(map);
      map.fitBounds(routeLine.getBounds());

      markers.push(L.marker(fromCoords).addTo(map).bindPopup("å‡ºç™ºåœ°"));
      markers.push(L.marker(toCoords).addTo(map).bindPopup("ç›®çš„åœ°"));

const distKm = (route.distance / 1000).toFixed(1);

// ã‚·ãƒ‹ã‚¢ã‚«ãƒ¼ã®å¹³å‡é€Ÿåº¦ï¼ˆ6km/hï¼‰ã§æ™‚é–“ã‚’å†è¨ˆç®—
  const seniorSpeed = 6; // km/h
  const timeMin = Math.round((distKm / seniorSpeed) * 60);

  summary.innerHTML = `<b>è·é›¢:</b> ${distKm} km ï¼ <b>æ‰€è¦æ™‚é–“ï¼ˆã‚·ãƒ‹ã‚¢ã‚«ãƒ¼ï¼‰:</b> ç´„${timeMin}åˆ†`;

  speak(`å‡ºç™ºåœ°ã‹ã‚‰ç›®çš„åœ°ã¾ã§ã®ãƒ«ãƒ¼ãƒˆã‚’æ¡ˆå†…ã—ã¾ã™ã€‚è·é›¢ã¯ç´„${distKm}ã‚­ãƒ­ã€ã‚·ãƒ‹ã‚¢ã‚«ãƒ¼ã§ã®æ‰€è¦æ™‚é–“ã¯ãŠã‚ˆã${timeMin}åˆ†ã§ã™ã€‚`);

    }

    function speak(text) {
      if (!("speechSynthesis" in window)) return;
      const utter = new SpeechSynthesisUtterance(text);
      utter.lang = "ja-JP";
      utter.rate = 1;
      speechSynthesis.speak(utter);
    }

    document.getElementById("gpsBtn").addEventListener("click", getCurrentLocation);
    document.getElementById("goBtn").addEventListener("click", drawRoute);

    // --- ARæ©Ÿèƒ½ã®å®Ÿè£… ---
    const arBtn = document.getElementById('arBtn');
    const arContainer = document.getElementById('arContainer');
    const cameraVideo = document.getElementById('cameraVideo');
    const arrowSvg = document.getElementById('arrowSvg');
    const arInfo = document.getElementById('arInfo');
    const arDistance = document.getElementById('arDistance');
    const arStatus = document.getElementById('arStatus');
    const stopArBtn = document.getElementById('stopArBtn');
    let arStream = null;
    let watchingPositionId = null;
    let deviceHeading = null; // degrees, 0 = north
    let orientationListener = null;

    // ãƒ˜ãƒ‡ã‚£ãƒ³ã‚°å–å¾—ï¼ˆDeviceOrientationAbsolute ã‚’å„ªå…ˆï¼‰
    function setupOrientationListener() {
      // iOS Safari ã§ã¯ DeviceOrientationEvent.requestPermission ãŒå¿…è¦
      function handleOrientation(e) {
        // alpha: rotation around z-axis (compass), but depends on device/browser.
        // Try to use 'webkitCompassHeading' where available (iOS).
        if (e.webkitCompassHeading !== undefined) {
          deviceHeading = e.webkitCompassHeading; // 0..360 (degrees clockwise from north)
        } else if (e.absolute === true || e.absolute === undefined) {
          // alpha rotation is degrees from device start; might need conversion based on screen orientation.
          if (e.alpha != null) {
            // Convert alpha to compass heading:
            // e.alpha: 0 at device's reference (magnetic north on some implementations). This is approximate.
            deviceHeading = 360 - e.alpha; // best-effort
          }
        }
      }

      // Modern browsers may require user gesture to request permission
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
          .then(permissionState => {
            if (permissionState === 'granted') {
              window.addEventListener('deviceorientation', handleOrientation, true);
              orientationListener = handleOrientation;
            } else {
              arStatus.textContent = "å‘ãæƒ…å ±ã®è¨±å¯ãŒå¿…è¦ã§ã™ï¼ˆè¡¨ç¤ºã¯ä¸æ­£ç¢ºã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ï¼‰";
            }
          })
          .catch(err => {
            console.warn('DeviceOrientation permission error', err);
            arStatus.textContent = "å‘ãæƒ…å ±ãŒå–å¾—ã§ãã¾ã›ã‚“ã€‚";
          });
      } else {
        // æ¨™æº–ã‚¤ãƒ™ãƒ³ãƒˆ
        window.addEventListener('deviceorientation', handleOrientation, true);
        orientationListener = handleOrientation;
      }
    }

    function stopOrientationListener() {
      if (orientationListener) {
        window.removeEventListener('deviceorientation', orientationListener, true);
        orientationListener = null;
      }
    }

    // ã‚«ãƒ¡ãƒ©é–‹å§‹
    async function startCamera() {
      try {
        arStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
        cameraVideo.srcObject = arStream;
        await cameraVideo.play();
        arContainer.style.display = 'block';
      } catch (err) {
        alert('ã‚«ãƒ¡ãƒ©ã‚’é–‹å§‹ã§ãã¾ã›ã‚“ã§ã—ãŸ: ' + err.message);
      }
    }

    function stopCamera() {
      if (arStream) {
        arStream.getTracks().forEach(t => t.stop());
        arStream = null;
      }
      cameraVideo.pause();
      cameraVideo.srcObject = null;
      arContainer.style.display = 'none';
    }

    // ï¼’ç‚¹ã®æ–¹ä½ï¼ˆbearingï¼‰ã‚’æ±‚ã‚ã‚‹ï¼ˆdegreesï¼‰
    function bearingBetween(lat1, lon1, lat2, lon2) {
      const toRad = Math.PI / 180;
      const toDeg = 180 / Math.PI;
      const Ï†1 = lat1 * toRad;
      const Ï†2 = lat2 * toRad;
      const Î»1 = lon1 * toRad;
      const Î»2 = lon2 * toRad;
      const y = Math.sin(Î»2 - Î»1) * Math.cos(Ï†2);
      const x = Math.cos(Ï†1) * Math.sin(Ï†2) - Math.sin(Ï†1) * Math.cos(Ï†2) * Math.cos(Î»2 - Î»1);
      let Î¸ = Math.atan2(y, x);
      Î¸ = Î¸ * toDeg;
      return (Î¸ + 360) % 360;
    }

    // è·é›¢ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰
    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const toRad = Math.PI / 180;
      const dLat = (lat2 - lat1) * toRad;
      const dLon = (lon2 - lon1) * toRad;
      const a = Math.sin(dLat/2)**2 + Math.cos(lat1*toRad)*Math.cos(lat2*toRad)*Math.sin(dLon/2)**2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    // ãƒ«ãƒ¼ãƒˆä¸Šã®ã€Œæ¬¡ã®æ³¨ç›®ç‚¹ã€ã‚’æ¢ã™ï¼ˆå˜ç´”ã«æœ€ã‚‚è¿‘ã„å¾Œæ–¹ã§ãªãå‰æ–¹ã®ãƒã‚¤ãƒ³ãƒˆï¼‰
    function findNextPointOnRoute(current) {
      if (!routeCoords || routeCoords.length === 0) return null;
      // ç¾åœ¨åœ°ã‹ã‚‰é †ã«æœ€è¿‘ç‚¹ã‚’æ¢ã™ï¼ˆã‚·ãƒ³ãƒ—ãƒ«å®Ÿè£…ï¼‰
      let minDist = Infinity;
      let idx = 0;
      for (let i = 0; i < routeCoords.length; i++) {
        const p = routeCoords[i];
        const d = haversineDistance(current[0], current[1], p[0], p[1]);
        if (d < minDist) {
          minDist = d; idx = i;
        }
      }
      // é€²è¡Œæ–¹å‘ã‚’è€ƒãˆã€idx+Nç‚¹ã‚’æ¬¡ã®ç›®æ¨™ã«ã™ã‚‹ï¼ˆN=5 ã»ã©ï¼‰
      const lookAhead = Math.min(idx + 8, routeCoords.length - 1);
      return { point: routeCoords[lookAhead], distToPoint: haversineDistance(current[0], current[1], routeCoords[lookAhead][0], routeCoords[lookAhead][1]) };
    }

    // ä½ç½®æ›´æ–°ãƒãƒ³ãƒ‰ãƒ©ï¼šARä¸­ã¯é »ç¹ã«å‘¼ã°ã‚Œã‚‹
    async function startWatchingPosition() {
      if (!navigator.geolocation) {
        alert('ä½ç½®æƒ…å ±ãŒä½¿ãˆã¾ã›ã‚“ã€‚');
        return;
      }
      if (watchingPositionId !== null) return;
      watchingPositionId = navigator.geolocation.watchPosition(pos => {
        currentLocation = [pos.coords.latitude, pos.coords.longitude];
        // ARè¡¨ç¤ºã‚’æ›´æ–°
        updateAR();
      }, err => {
        console.warn('ä½ç½®ç›£è¦–ã‚¨ãƒ©ãƒ¼', err);
      }, { enableHighAccuracy: true, maximumAge: 1000, timeout: 5000 });
    }

    function stopWatchingPosition() {
      if (watchingPositionId !== null) {
        navigator.geolocation.clearWatch(watchingPositionId);
        watchingPositionId = null;
      }
    }

    // ARè¡¨ç¤ºæ›´æ–°ï¼ˆçŸ¢å°ã®å›è»¢ã€è·é›¢è¡¨ç¤ºã€éŸ³å£°æ¡ˆå†…ãƒˆãƒªã‚¬ï¼‰
    let lastSpokenStep = null;
    function updateAR() {
      if (!currentLocation || !routeCoords || routeCoords.length === 0) {
        arInfo.textContent = '-- m';
        return;
      }
      const next = findNextPointOnRoute(currentLocation);
      if (!next) return;
      const target = next.point; // [lat,lon]
      const dist = Math.round(next.distToPoint);
      const bearingToTarget = bearingBetween(currentLocation[0], currentLocation[1], target[0], target[1]); // degrees
      const heading = (deviceHeading != null) ? deviceHeading : 0; // degrees
      const relative = ((bearingToTarget - heading + 540) % 360) - 180; // -180..180 (right positive)
      // rotate arrow: because video is mirrored via CSS scaleX(-1), invert rotation sign for natural feel
      arrowSvg.style.transform = `rotate(${relative}deg)`;

      arInfo.textContent = `${dist} m`;
      arDistance.textContent = `ç›®æ¨™ã¾ã§ ${dist} m`;

      // æ¡ˆå†…ã®ç™ºè©±ï¼ˆè¿‘ã¥ã„ãŸã‚‰æ¬¡ã®éŸ³å£°ï¼‰
      if (dist < 50 && lastSpokenStep !== 'near') {
        speak('ç›®çš„åœ°ãŒè¿‘ã¥ã„ã¦ã„ã¾ã™ã€‚æ¸›é€Ÿã—ã¦ã”æ³¨æ„ãã ã•ã„ã€‚');
        lastSpokenStep = 'near';
      } else if (dist >= 50) {
        lastSpokenStep = null;
      }
    }

    // ARé–‹å§‹
    arBtn.addEventListener('click', async () => {
      // ãƒ«ãƒ¼ãƒˆãŒç„¡ã‘ã‚Œã°å…ˆã«ä½œæˆã‚’ä¿ƒã™
      if (!route || !routeCoords || routeCoords.length === 0) {
        alert('ARã‚’ä½¿ã†å‰ã«ã€Œãƒ«ãƒ¼ãƒˆè¡¨ç¤ºã€ã§ç›®çš„åœ°ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚');
        return;
      }

      // ã‚«ãƒ¡ãƒ©é–‹å§‹
      await startCamera();

      // å‘ãæƒ…å ±ã®ãƒªã‚¹ãƒŠãƒ¼ã‚’ã‚»ãƒƒãƒˆ
      setupOrientationListener();

      // ä½ç½®æ›´æ–°ç›£è¦–
      await startWatchingPosition();

      // show overlay
      arContainer.style.display = 'block';
      arStatus.textContent = 'ARãƒ¢ãƒ¼ãƒ‰ï¼ˆã‚«ãƒ¡ãƒ©ãƒ»ä½ç½®ãƒ»æ–¹ä½ã‚’ä½¿ç”¨ï¼‰';
      speak('ARãƒŠãƒ“ã‚’é–‹å§‹ã—ã¾ã™ã€‚ç«¯æœ«ã‚’å›ã—ã¦é€²è¡Œæ–¹å‘ã‚’åˆã‚ã›ã¦ãã ã•ã„ã€‚');

      // åˆå›æ›´æ–°
      updateAR();
    });

    stopArBtn.addEventListener('click', () => {
      stopCamera();
      stopWatchingPosition();
      stopOrientationListener();
      arContainer.style.display = 'none';
      speak('ARãƒ¢ãƒ¼ãƒ‰ã‚’çµ‚äº†ã—ã¾ã—ãŸã€‚');
    });

    // ãƒšãƒ¼ã‚¸é›¢è„±æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    window.addEventListener('beforeunload', () => {
      stopCamera(); stopWatchingPosition(); stopOrientationListener();
    });

    // (ã‚ªãƒ—ã‚·ãƒ§ãƒ³) mapã‚¯ãƒªãƒƒã‚¯ã§ç¾åœ¨åœ°æ›´æ–°
    map.on('click', (e) => {
      // debug: ãƒãƒƒãƒ—ã‚’ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨ç¾åœ¨ä½ç½®ã‚’ã‚»ãƒƒãƒˆï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
      currentLocation = [e.latlng.lat, e.latlng.lng];
      if (routeLine) {
        map.panTo(e.latlng);
      }
    });

    // æœ€å¾Œã«â€”åˆå›ã®ç°¡æ˜“ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    document.addEventListener('DOMContentLoaded', () => {
      const s = document.getElementById('summary');
      s.textContent = 'ç›®çš„åœ°ã‚’å…¥åŠ›ã—ã¦ã€Œãƒ«ãƒ¼ãƒˆè¡¨ç¤ºã€ã€‚ARãƒ¢ãƒ¼ãƒ‰ã¯å±‹å¤–ã§ã®ä½¿ç”¨ã‚’æƒ³å®šã—ã¦ã„ã¾ã™ã€‚';
    });
  </script>
</body>
</html>
